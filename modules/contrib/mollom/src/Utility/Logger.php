<?php

namespace Drupal\mollom\Utility;

use \Drupal\Core\Logger\RfcLogLevel;

class Logger {

  /**
   * Adds a log entry to a global log (per-request).
   *
   * The Mollom client may perform multiple requests, and the client is able to
   * recover from certain errors. The details of each request are important for
   * support and debugging, but individual log messages for each request are too
   * much and would confuse users, especially when (false-)errors appear in
   * between.
   *
   * Therefore, the Mollom module collects all messages generated by the module
   * integration code as well as by the Mollom client class within a single
   * request, and only logs a single message when the request ends.
   *
   * This collection expects that at least one entry is logged that contains the
   * primary log message and its severity.
   *
   * @param array $entry
   *   (optional) An associative array describing the entry to add to the log.
   *   If supplied, the special keys 'message' and 'arguments' are taken over as
   *   primary log message. All other key/value pairs will be appended to the
   *   resulting log message, whereas the key denotes a label/heading and the
   *   value is var_export()ed afterwards, unless NULL.
   * @param int $severity
   *   (optional) The severity of the primary log message, as per RFC 3164.
   *   Possible values are WATCHDOG_ERROR, WATCHDOG_WARNING, etc. See watchdog()
   *   for details. Defaults to WATCHDOG_NOTICE when a 'message' is passed.
   * @param bool $reset
   *   (optional) Whether to empty the log and return its contents.
   *
   * @return array
   *   An associative array containing the log:
   *   - message: The primary log message.
   *   - arguments: An array of placeholder token replacement values for
   *     _mollom_format_string().
   *   - severity: The severity of the primary log message.
   *   - entries: A list of all $entry items that have been passed in.
   *
   * @see mollom_exit()
   */
  static public function addMessage(array $entry = NULL, $severity = NULL, $reset = FALSE) {
    // Start with debug severity level.
    $log = &drupal_static(__FUNCTION__, array());

    if ($reset) {
      $return = $log;
      $log = array();
      return $return;
    }
    if (!isset($entry)) {
      return $log;
    }
    // Take over the primary message.
    // Only the module integration code sets a message.
    if (isset($entry['message'])) {
      $log['message'] = $entry['message'];
      $log['arguments'] = isset($entry['arguments']) ? $entry['arguments'] : array();

      // Default to notice severity for module messages.
      if (!isset($severity)) {
        $severity = RfcLogLevel::NOTICE;
      }
    }

    if (!isset($log['severity'])) {
      $log['severity'] = RfcLogLevel::DEBUG;
    }
    // Update severity, if the entry is more severe than existing.
    // Fail-over handling for requests is encapsulated in the Mollom class, which
    // only passes the final severity already.
    if (isset($severity) && $severity < $log['severity']) {
      $log['severity'] = $severity;
    }

    $log['entries'][] = $entry;

    return $log;
  }

  /**
   * Helper function for quick log dumps within the logs.
   * @param any $data
   *   The data to dump.
   * @param string $label
   *   A label to show prior to the data dump.
   *
   * @todo: Remove after release of 8.x module.
   */
  static public function developerLog($data, $label = '') {
    static::addMessage(array('message' => $label . ' <pre>' . print_r($data, TRUE) . '</pre>'));
  }

  /**
   * Logs a single system message potentially containing multiple Mollom log entries.
   *
   * @see mollom_log()
   * @see _mollom_format_log()
   * @see watchdog()
   */
  static public function writeLog() {
    $config = \Drupal::config('mollom.settings');
    // Retrieve the log and reset it.
    $log = static::addMessage(NULL, NULL, TRUE);
    if (empty($log)) {
      return;
    }
    // Only log if severity if it meets configured minimum severity, or if testing
    // mode is enabled.
    if ($config->get('test_mode.enabled') || $log['severity'] < $config->get('log_level')) {
      list($message, $arguments) = static::formatLog($log);
      \Drupal::logger('mollom')->log($log['severity'], $message, $arguments);
    }
  }

  /**
   * Log a Mollom system message.
   *
   * @param $log
   *   @todo A list of message parts. Each item is an associative array whose keys are
   *   log message strings and whose corresponding values are t()-style
   *   replacement token arguments. At least one part is required.
   *
   * In essence, this is a poor man's YAML implementation (give or take some
   * details, but note especially the indentation for array sub-elements).
   */
  static protected function formatLog(array $log) {
    $message = isset($log['message']) ? $log['message'] : '';
    $arguments = isset($log['arguments']) ? $log['arguments'] : array();

    // Hide further message details in the log overview table, if any.
    // @see theme_dblog_message()
    if (!empty($log['entries'])) {
      // A <br> would be more appropriate, but filter_xss_admin() does not allow it.
      //$message = '<p>' . $message . '</p>' . "\n\n";
      $message = $message . "<p>\n\n</p>";
    }

    // Walk through each log entry to prepare and format its message and arguments.
    $i = 0;
    foreach ($log['entries'] as $entry) {
      // Take over message and arguments literally (if any).
      if (isset($entry['message'])) {
        $message .= '<p>';
        if (!empty($entry['arguments'])) {
          $message .= static::formatLogString($entry['message'], $entry['arguments']);
          unset($entry['arguments']);
        }
        else {
          $message .= $entry['message'];
        }
        unset($entry['message']);
        $message .= "</p>\n";
      }
      unset($entry['severity']);

      // Prettify replacement token values, if possible.
      foreach ($entry as $token => $array) {
        // Only prettify non-scalar values plus Booleans.
        // I.e., NULL, TRUE, FALSE, array, and object.
        if (is_scalar($array) && !is_bool($array)) {
          $value = $array;
        }
        else {
          $flat_value = NULL;
          // Convert arrays and objects.
          // @todo Objects?
          if (isset($array) && !is_scalar($array)) {
            $ref = &$array;
            $key = key($ref);
            $parents = array();
            $flat_value = '';
            while ($key !== NULL) {
              if (is_scalar($ref[$key]) || is_bool($ref[$key]) || is_null($ref[$key])) {
                $value = var_export($ref[$key], TRUE);
                // Indent all values to have a visual separation from the last.
                $flat_value .= str_repeat('  ', count($parents) + 1) . "{$key} = {$value}\n";
              }
              if (is_array($ref[$key])) {
                $flat_value .= str_repeat('  ', count($parents) + 1) . "{$key} =\n";
              }

              // Recurse into nested keys, if the current key is not scalar.
              if (is_array($ref[$key]) && !empty($ref[$key])) {
                $parents[] = &$ref;
                $ref = &$ref[$key];
                $key = key($ref);
              }
              else {
                // Move to next key if there is one.
                next($ref);
                if (key($ref) !== NULL) {
                  $key = key($ref);
                }
                // Move back to parent key, if there is one.
                elseif ($parent = array_pop($parents)) {
                  $ref = &$parent;
                  next($ref);
                  $key = key($ref);
                }
                // Otherwise, reached the end of array and recursion.
                else {
                  $key = NULL;
                }
              }
            }
          }
          $value = NULL;
          // Use prettified string representation.
          if ($flat_value !== NULL) {
            $value = $flat_value;
          }
          // Use var_export() for Booleans.
          // Do not output NULL values on the top-level to allow for labels without
          // following value.
          elseif ($array !== NULL) {
            $value = var_export($array, TRUE);
          }
        }

        // Inject all other key/value pairs as @headingN (and optional
        // '<pre>@valueN</pre>') placeholders.
        if (isset($value)) {
          $message .= "@heading{$i}\n<pre>@value{$i}</pre>\n";
          $arguments += array(
            '@heading' . $i => $token,
            '@value' . $i => $value,
          );
        }
        else {
          $message .= "<p>@heading{$i}</p>\n";
          $arguments += array(
            '@heading' . $i => $token,
          );
        }
        $i++;
      }
    }
    return array($message, $arguments);
  }

  /**
   * Replaces placeholders with sanitized values in a string.
   *
   * Backported from Drupal 8.
   *
   * @param $string
   *   A string containing placeholders.
   * @param $args
   *   An associative array of replacements to make. Occurrences in $string of
   *   any key in $args are replaced with the corresponding value, after
   *   sanitization. The sanitization function depends on the first character of
   *   the key:
   *   - !variable: Inserted as is. Use this for text that has already been
   *     sanitized.
   *   - @variable: Escaped to HTML using check_plain(). Use this for anything
   *     displayed on a page on the site.
   *   - %variable: Escaped as a placeholder for user-submitted content using
   *     drupal_placeholder(), which shows up as <em>emphasized</em> text.
   *
   * @see t()
   * @ingroup sanitization
   */
  static protected function formatLogString($string, array $args = array()) {
    return \Drupal\Component\Utility\SafeMarkup::format($string, $args);
  }
}
